---
title: Testando Componentes e Controllers
---

# Testando Componentes e Controllers

Fazer testes unitários com o VRaptor 4 na maioria das vezes é simples, não fugindo muito dos testes unitários de uma classe qualquer.

Todo o controle de Injeção de Dependência é feito através do CDI, isso pode dificultar um pouco a sua vida na hora de criar os testes unitários se você faz a DI via atributos, no entanto se você faz via contrutor, tudo fica mais fácil. A vantagem de se fazer via construtor é que podemos passar nossas dependências via parâmetro no mesmo.

O que acontece quando fazemos a DI via atributo, é que precisaremos do contexto do CDI e o mesmo não é suportado pelo JUnit, visto que esse cria todo um ambiente para os testes e não levanta esse contexto. No entanto há soluções para que você possa dentro do seu caso de teste subir o contexto CDI e assim usufruir das injeções de dependências, controle transacionais e tudo aquilo que você precisa do CDI, uma delas é o Arquillian(http://arquillian.org/) que por sinal possui uma excelente documentação, além de que você pode encontrar vários artigos na internet.

Os componentes do VRaptor mais presentes em sua aplicação são o Result e o Validator, esses por serem um pouco mais complexos, com interface fluente, dificulta a criação de mocks(falsas implementações). Com o intuito de facilitar a nossa vida nos testes, o VRaptor nos disponibiliza esses mocks já implementados, são eles: MockResult e MockValidator.

Para os exemplos dos testes, usaremos o seguinte Controller:
~~~
#!java
@Controller
public class PessoaController {

	private Result result;
	private Validator validator;

	@Inject
	public PessoaController(Result result, Validator validator) {
		this.result = result;
		this.validator = validator;
	}

	/**
	 * @deprecated CDI eyes only
	 */
	public PessoaController() {
	}
	
	@Post
	@Path("/pessoa/add")
	public void add(Pessoa pessoa) {
		validator.addIf(pessoa.getNome() == null, new SimpleMessage("nome", "O nome deve ser preenchido"));
		validator.onErrorRedirectTo(IndexController.class).index();
		
		//chamadas de DAOs, Services...

		result.include("success", "Incluído com sucesso.");
		
		result.redirectTo(IndexController.class).index();
	}
	
}
~~~

##MockResult

O MockResult ignora os redirecionamentos que você fizer, e acumula os objetos incluídos, para você poder inspecioná-los e fazer as suas asserções. Um exemplo de uso seria:

~~~
#!java
public class PessoaControllerTest {

	private MockResult result;
	private PessoaController controller;
	
	@Before
	public void setUp() {
		result = new MockResult();
		controller = new PessoaController(result); //Passamos o MockResult como dependência do nosso controller
	}
	
	@Test
	public void shouldHaveSuccessMessage() {
		Pessoa pessoa = new Pessoa();
		pessoa.setNome("Renan Montenegro");
		
		controller.add(pessoa);
		
		Assert.assertTrue(result.included().containsKey("success"));
		Assert.assertEquals("Incluído com sucesso.", result.included("success"));
	}
	
}
~~~

OBS: Quaisquer chamadas do tipo result.use(...) serão ignoradas.

##MockValidator

Como estamos fora do contexto CDI, vamos abordar apenas o caso de validação do próprio Validator do VRaptor.
O MockValidator vai acumular os erros gerados, e quando o validator.onErrorUse for chamado, vai lançar um ValidationException caso haja algum erro. Assim, você pode inspecionar os erros adicionados, ou simplesmente ver se deu algum erro. Segue um exemplo de uso:

Os testes de validação podem ser feitos das seguintes formas:

~~~
#!java
public class PessoaControllerTest {

	private MockResult result;
	private MockValidator validator;
	private PessoaController controller;
	
	@Before
	public void setUp() {
		result = new MockResult();
		validator = new MockValidator();
		controller = new PessoaController(result, validator); //MockResult e MockValidator como dependência do nosso controller
	}

	@Test(expected = ValidationException.class)
	public void shouldThrowValidationException() {
		controller.add(new Pessoa());
	}
	
}
~~~

Ou no método shouldThrowValidationException da classe de teste, usarmos da seguinte forma:

~~~
#!java
@Test
public void shouldThrowValidationException() {
	try {
		controller.add(new Pessoa());
		Assert.fail();
	} catch (ValidationException e) {
		List<Message> errors = e.getErrors();
	        //asserts nos erros
	}
}
~~~
