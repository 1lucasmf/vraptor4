---
title: Building a Web Application With Java 8 and VRaptor 4 in the Wildfly
---

# by Rubens Saraiva

There is little more two month we follow the launch Java 1.8, with new features and new APIs. In the same way, and almost at the same time, arrived the version 4 of Vraptor, Brazilian framework who have been increasingly used in the Brazil and other places of world.

The VRaptor 4 was totally modified for using the CDI in your engine de Injection Dependency. This makes the framework totally compatible with the Java Enterprise Edition platform (JavaEE).

In this post I will show how building a Vraptor 4 Application, used new features of Java 8 and running on the WildFly 8, the new application server of Jboss who implements Java EE 7.In relation to database, the application uses the WildFly default datasource who uses HSQLDB Database.

The complete application code is available [here](http://github.com/rsaraiva/v4_wildfly_jta).

To begin, create a project web with Maven using your favorite IDE. Open the Maven configuration file , `pom.xml` and include the dependencies contained in the file below.

~~~
#!xml
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.rsaraiva.labs</groupId>
    <artifactId>events</artifactId>
    <version>1.0</version>
    <packaging>war</packaging>
    <name>events</name>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>br.com.caelum</groupId>
            <artifactId>vraptor</artifactId>
            <version>4.0.0.Final</version>
        </dependency>
        <dependency>
            <groupId>br.com.caelum.vraptor</groupId>
            <artifactId>vraptor-javatime</artifactId>
            <version>4.0.0.Final</version>
        </dependency>
        <dependency>
            <groupId>jstl</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>4.3.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.inject</groupId>
            <artifactId>javax.inject</artifactId>
            <version>1</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax</groupId>
            <artifactId>javaee-web-api</artifactId>
            <version>7.0</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
~~~

The first dependency is the new VRaptor 4, final version. Next we included the plugin `vraptor-javatime` that makes the VRaptor recognize all types of new date API. After comes the dependency of JSTL for to work in the JSPs, the hibernate, the CDI library and in the final, the Java EE 7 library. In tag plugins, we defined who we want to use Java 8 in the build of the application.

Now, come on create our model - a simple entity to represent Events.

~~~
#!java
@Entity
public class Event implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private LocalDate date;

    private String description;

    public Event() {
    }

    public Event(String description, LocalDate date) {
        this.description = description;
        this.date = date;
    }

    // gets and sets
}
~~~

See that the date attribute is of type `LocalDate`, the new class of api dates of java 8.

Mas para isso ser possível, é necessário criar um Converter da JPA, já que a JPA 2.1 ainda não suporta os tipos da nova Date and Time API.
But for that to be possible, it's necessary create a JPA Converter, since the JPA 2.1 still not support the types of the new Date and Time API.
~~~
#!java
@Converter(autoApply = true)
public class LocalDatePersistenceConverter implements AttributeConverter<LocalDate, Date> {

    @Override
    public Date convertToDatabaseColumn(LocalDate entityValue) {
        return (entityValue == null) ? null : Date.valueOf(entityValue);
    }

    @Override
    public LocalDate convertToEntityAttribute(Date databaseValue) {
        return databaseValue.toLocalDate();
    }
}
~~~

This converter need to be registered in the `persistence.xml` how below.

~~~
#!xml
<persistence version="2.1" xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
  <persistence-unit name="default" transaction-type="JTA">
    <jta-data-source>java:jboss/datasources/ExampleDS</jta-data-source>
    <class>com.rsaraiva.labs.vraptor4.jpa.LocalDatePersistenceConverter</class>
    <properties>
      <property name="hibernate.transaction.jta.platform" value="org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform"/>
      <property name="hibernate.hbm2ddl.auto" value="update"/>
    </properties>
  </persistence-unit>
</persistence>
~~~

Now come on create a `Service` who knows create a new event and list all events.Note the integration with JavaEE by the use of annotation `@Stateless` and `@PersistenceContext`.

~~~
#!java
@Stateless
public class EventService {
    
    @PersistenceContext
    private EntityManager em;

    public void persist(Event event) {
        em.persist(event);
    }
    
    public List<Event> findAll() {
        return em.createQuery("select e from Event e order by e.description").getResultList();
    }
}
~~~

Now we will use the CDI for inject the service in the controller from VRaptor

~~~
#!java
@Controller
public class EventController implements Serializable {

    @Inject private EventService service;
    @Inject private Result result;

    @Get("/events")
    public void event() {
        result.include("events", service.findAll());
    }

    @Post
    public void add(Event event) {
        service.persist(event);
        result.redirectTo(this).event();
    }
}
~~~

Our controller have two methods. The first uses `EventService` for consulting all events registered and includes the list in the JSP context. The second receive the 'post' of JSP form and persists the event in database.

In the end, we must create a jsp with a events list and the register form.

~~~
#!jsp
<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Events</title>
    </head>
    <body>
        <h1>Events</h1>
        <table>
            <c:forEach items="${events}" var="item">
                <tr>
                    <td>${item.id}</td>
                    <td>${item.description}</td>
                    <td>${item.formattedDate}</td>
                </tr>
            </c:forEach>
        </table>
        <br/>
        <form action="${linkTo[EventController].add}" method="post">
            <span>Description: </span>
            <input type="input" name="event.description"/>
            <span>Date </span>
            <input type="input" name="event.date"/>
            <button>Add</button>
        </form>
    </body>
</html>
~~~

Cookbook originally posted in [rsaraiva.com](http://rsaraiva.com)

