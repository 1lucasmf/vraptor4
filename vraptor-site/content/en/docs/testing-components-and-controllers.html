---
title: Testing Components and Controllers
---

# Testing Components and Controllers

Do unit tests with VRaptor 4 is often simple, which isn't so different from unit tests of any class.

All the control of Dependency Injection is made by CDI and to improve the testability of your class, we advise the dependency injection by constructor, thus you may work easily with mocks, such as:

~~~
#!java
@Controller
public class PersonController {

	private final Result result;
	private final Validator validator;

	@Inject
	public PersonController(Result result, Validator validator) {
		this.result = result;
		this.validator = validator;
	}

	/**
	 * @deprecated CDI eyes only
	 */
	public PersonController() {
		this(null, null);
	}
	
}
~~~

To test your controller, we can use the `MockResult` and `MockValidator` as dependency:

~~~
#!java
public class PersonControllerTest {

	private MockResult result;
	private MockValidator validator;
	private PersonController controller;
	
	@Before
	public void setUp() {
		result = new MockResult();
		validator = new MockValidator();
		controller = new PersonController(result, validator);
	}
	
}
~~~

What happens when we made the dependency injection by attribute, as that we need the CDI context and itself isn't supported by JUnit, since it creates all an enviroment for the tests and donâ€™t up this context. However there are solutions to help you in your test case to up the CDI context and enjoy of the dependency injection, transaction control and all that you need of CDI.

`Result` and `Validator` are components almost always present in your Controllers, to make your tests easier the VRaptor provides mocks for these implementations.

##MockResult

The `MockResult` ignores the redirecting that you do, and collects the included objects, so you can inspect them and make your assertions.

Consider the following method of the class `PersonController`:

~~~
#!java
@Post("/person/add")
public void add(Person person) {
	validator.addIf(person.getName() == null, new SimpleMessage("name", "The name should be filled."));
	validator.onErrorRedirectTo(IndexController.class).index();

	result.include("success", "Successfully added.");
	
	result.redirectTo(IndexController.class).index();
}
~~~

To test it you can use on your class `PersonControllerTest` something like:

~~~
#!java
@Test
public void shouldHaveSuccessMessage() {
	Person person = new Person();
	person.setName("Renan Montenegro");
	
	controller.add(person);
	
	Assert.assertTrue(result.included().containsKey("success"));
	Assert.assertEquals("Successfully added.", result.included("success"));
}
~~~

Note that any call of the type `result.use(...)` will be ignored.

##MockValidator

The `MockValidator` will execute the validation accumulating possible errors. To retrieve them you can use the method `getErrors()` as you can see in the example:

~~~
#!java
@Test
public void shouldThrowValidationException() {
	try {
		controller.add(new Person());
		Assert.fail();
	} catch (ValidationException e) {
		List<Message> errors = e.getErrors();
		Assert.assertTrue(errors.contains(new SimpleMessage("name", "The name should be filled.")));
		Assert.assertEquals(1, errors.size());
	}
}
~~~

The calling of the method `validator.onErrorUse`, in case of validation problem, will generate a `ValidationException`, that can be used as an expected result by your test, as the following:

~~~
#!java
@Test(expected = ValidationException.class)
public void shouldThrowValidationException() {
	controller.add(new Person());
}
~~~
